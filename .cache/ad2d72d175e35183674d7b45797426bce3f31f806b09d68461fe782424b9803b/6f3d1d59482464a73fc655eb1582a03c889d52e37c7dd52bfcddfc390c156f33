/* https://cdn.esm.sh/v41/workbox-strategies@6.1.5/deno/workbox-strategies.js */
const mod9 = (async () => {
    var D = Object.defineProperty;
    var P = (n, e) => {
        for (var r in e)
            D(n, r, { get: e[r], enumerable: !0 });
    };
    var R = {};
    P(R, { CacheFirst: () => k, CacheOnly: () => E, NetworkFirst: () => x, NetworkOnly: () => N, StaleWhileRevalidate: () => $, Strategy: () => l, StrategyHandler: () => h });
    "use strict";
    try {
        self["workbox:core:6.1.5"] && _();
    }
    catch (n) { }
    var W = (n, ...e) => { let r = n; return e.length > 0 && (r += ` :: ${JSON.stringify(e)}`), r; };
    var j = W;
    var c = class extends Error {
        constructor(e, r) { let t = j(e, r); super(t); this.name = e, this.details = r; }
    };
    var p = { googleAnalytics: "googleAnalytics", precache: "precache-v2", prefix: "workbox", runtime: "runtime", suffix: typeof registration != "undefined" ? registration.scope : "" }, y = n => [p.prefix, n, p.suffix].filter(e => e && e.length > 0).join("-"), F = n => {
        for (let e of Object.keys(p))
            n(e);
    }, O = { updateDetails: n => { F(e => { typeof n[e] == "string" && (p[e] = n[e]); }); }, getGoogleAnalyticsName: n => n || y(p.googleAnalytics), getPrecacheName: n => n || y(p.precache), getPrefix: () => p.prefix, getRuntimeName: n => n || y(p.runtime), getSuffix: () => p.suffix };
    var b = n => new URL(String(n), location.href).href.replace(new RegExp(`^${location.origin}`), "");
    function q(n, e) {
        let r = new URL(n);
        for (let t of e)
            r.searchParams.delete(t);
        return r.href;
    }
    async function C(n, e, r, t) {
        let o = q(e.url, r);
        if (e.url === o)
            return n.match(e, t);
        let a = { ...t, ignoreSearch: !0 }, s = await n.keys(e, a);
        for (let i of s) {
            let u = q(i.url, r);
            if (o === u)
                return n.match(i, t);
        }
    }
    var v = class {
        constructor() { this.promise = new Promise((e, r) => { this.resolve = e, this.reject = r; }); }
    };
    var T = new Set;
    async function S() {
        for (let n of T)
            await n();
    }
    function d(n) { return new Promise(e => setTimeout(e, n)); }
    "use strict";
    try {
        self["workbox:strategies:6.1.5"] && _();
    }
    catch (n) { }
    function m(n) { return typeof n == "string" ? new Request(n) : n; }
    var h = class {
        constructor(e, r) {
            this._cacheKeys = {}, Object.assign(this, r), this.event = r.event, this._strategy = e, this._handlerDeferred = new v, this._extendLifetimePromises = [], this._plugins = [...e.plugins], this._pluginStateMap = new Map;
            for (let t of this._plugins)
                this._pluginStateMap.set(t, {});
            this.event.waitUntil(this._handlerDeferred.promise);
        }
        async fetch(e) {
            let { event: r } = this, t = m(e);
            if (t.mode === "navigate" && r instanceof FetchEvent && r.preloadResponse) {
                let s = await r.preloadResponse;
                if (s)
                    return s;
            }
            let o = this.hasCallback("fetchDidFail") ? t.clone() : null;
            try {
                for (let s of this.iterateCallbacks("requestWillFetch"))
                    t = await s({ request: t.clone(), event: r });
            }
            catch (s) {
                throw new c("plugin-error-request-will-fetch", { thrownError: s });
            }
            let a = t.clone();
            try {
                let s;
                s = await fetch(t, t.mode === "navigate" ? void 0 : this._strategy.fetchOptions);
                for (let i of this.iterateCallbacks("fetchDidSucceed"))
                    s = await i({ event: r, request: a, response: s });
                return s;
            }
            catch (s) {
                throw o && await this.runCallbacks("fetchDidFail", { error: s, event: r, originalRequest: o.clone(), request: a.clone() }), s;
            }
        }
        async fetchAndCachePut(e) { let r = await this.fetch(e), t = r.clone(); return this.waitUntil(this.cachePut(e, t)), r; }
        async cacheMatch(e) {
            let r = m(e), t, { cacheName: o, matchOptions: a } = this._strategy, s = await this.getCacheKey(r, "read"), i = { ...a, cacheName: o };
            t = await caches.match(s, i);
            for (let u of this.iterateCallbacks("cachedResponseWillBeUsed"))
                t = await u({ cacheName: o, matchOptions: a, cachedResponse: t, request: s, event: this.event }) || void 0;
            return t;
        }
        async cachePut(e, r) {
            let t = m(e);
            await d(0);
            let o = await this.getCacheKey(t, "write");
            if (!r)
                throw new c("cache-put-with-no-response", { url: b(o.url) });
            let a = await this._ensureResponseSafeToCache(r);
            if (!a)
                return !1;
            let { cacheName: s, matchOptions: i } = this._strategy, u = await self.caches.open(s), g = this.hasCallback("cacheDidUpdate"), U = g ? await C(u, o.clone(), ["__WB_REVISION__"], i) : null;
            try {
                await u.put(o, g ? a.clone() : a);
            }
            catch (f) {
                throw f.name === "QuotaExceededError" && await S(), f;
            }
            for (let f of this.iterateCallbacks("cacheDidUpdate"))
                await f({ cacheName: s, oldResponse: U, newResponse: a.clone(), request: o, event: this.event });
            return !0;
        }
        async getCacheKey(e, r) {
            if (!this._cacheKeys[r]) {
                let t = e;
                for (let o of this.iterateCallbacks("cacheKeyWillBeUsed"))
                    t = m(await o({ mode: r, request: t, event: this.event, params: this.params }));
                this._cacheKeys[r] = t;
            }
            return this._cacheKeys[r];
        }
        hasCallback(e) {
            for (let r of this._strategy.plugins)
                if (e in r)
                    return !0;
            return !1;
        }
        async runCallbacks(e, r) {
            for (let t of this.iterateCallbacks(e))
                await t(r);
        }
        *iterateCallbacks(e) {
            for (let r of this._strategy.plugins)
                if (typeof r[e] == "function") {
                    let t = this._pluginStateMap.get(r);
                    yield a => { let s = { ...a, state: t }; return r[e](s); };
                }
        }
        waitUntil(e) { return this._extendLifetimePromises.push(e), e; }
        async doneWaiting() {
            let e;
            for (; e = this._extendLifetimePromises.shift();)
                await e;
        }
        destroy() { this._handlerDeferred.resolve(); }
        async _ensureResponseSafeToCache(e) {
            let r = e, t = !1;
            for (let o of this.iterateCallbacks("cacheWillUpdate"))
                if (r = await o({ request: this.request, response: r, event: this.event }) || void 0, t = !0, !r)
                    break;
            return t || r && r.status !== 200 && (r = void 0), r;
        }
    };
    var l = class {
        constructor(e = {}) { this.cacheName = O.getRuntimeName(e.cacheName), this.plugins = e.plugins || [], this.fetchOptions = e.fetchOptions, this.matchOptions = e.matchOptions; }
        handle(e) { let [r] = this.handleAll(e); return r; }
        handleAll(e) { e instanceof FetchEvent && (e = { event: e, request: e.request }); let r = e.event, t = typeof e.request == "string" ? new Request(e.request) : e.request, o = "params" in e ? e.params : void 0, a = new h(this, { event: r, request: t, params: o }), s = this._getResponse(a, t, r), i = this._awaitComplete(s, a, t, r); return [s, i]; }
        async _getResponse(e, r, t) {
            await e.runCallbacks("handlerWillStart", { event: t, request: r });
            let o;
            try {
                if (o = await this._handle(r, e), !o || o.type === "error")
                    throw new c("no-response", { url: r.url });
            }
            catch (a) {
                for (let s of e.iterateCallbacks("handlerDidError"))
                    if (o = await s({ error: a, event: t, request: r }), o)
                        break;
                if (!o)
                    throw a;
            }
            for (let a of e.iterateCallbacks("handlerWillRespond"))
                o = await a({ event: t, request: r, response: o });
            return o;
        }
        async _awaitComplete(e, r, t, o) {
            let a, s;
            try {
                a = await e;
            }
            catch (i) { }
            try {
                await r.runCallbacks("handlerDidRespond", { event: o, request: t, response: a }), await r.doneWaiting();
            }
            catch (i) {
                s = i;
            }
            if (await r.runCallbacks("handlerDidComplete", { event: o, request: t, response: a, error: s }), r.destroy(), s)
                throw s;
        }
    };
    var k = class extends l {
        async _handle(e, r) {
            let t = [], o = await r.cacheMatch(e), a;
            if (!o)
                try {
                    o = await r.fetchAndCachePut(e);
                }
                catch (s) {
                    a = s;
                }
            if (!o)
                throw new c("no-response", { url: e.url, error: a });
            return o;
        }
    };
    var E = class extends l {
        async _handle(e, r) {
            let t = await r.cacheMatch(e);
            if (!t)
                throw new c("no-response", { url: e.url });
            return t;
        }
    };
    var w = { cacheWillUpdate: async ({ response: n }) => n.status === 200 || n.status === 0 ? n : null };
    var x = class extends l {
        constructor(e = {}) { super(e); this.plugins.some(r => "cacheWillUpdate" in r) || this.plugins.unshift(w), this._networkTimeoutSeconds = e.networkTimeoutSeconds || 0; }
        async _handle(e, r) {
            let t = [], o = [], a;
            if (this._networkTimeoutSeconds) {
                let { id: u, promise: g } = this._getTimeoutPromise({ request: e, logs: t, handler: r });
                a = u, o.push(g);
            }
            let s = this._getNetworkPromise({ timeoutId: a, request: e, logs: t, handler: r });
            o.push(s);
            let i = await r.waitUntil((async () => await r.waitUntil(Promise.race(o)) || await s)());
            if (!i)
                throw new c("no-response", { url: e.url });
            return i;
        }
        _getTimeoutPromise({ request: e, logs: r, handler: t }) { let o; return { promise: new Promise(s => { o = setTimeout(async () => { s(await t.cacheMatch(e)); }, this._networkTimeoutSeconds * 1000); }), id: o }; }
        async _getNetworkPromise({ timeoutId: e, request: r, logs: t, handler: o }) {
            let a, s;
            try {
                s = await o.fetchAndCachePut(r);
            }
            catch (i) {
                a = i;
            }
            return e && clearTimeout(e), (a || !s) && (s = await o.cacheMatch(r)), s;
        }
    };
    var N = class extends l {
        constructor(e = {}) { super(e); this._networkTimeoutSeconds = e.networkTimeoutSeconds || 0; }
        async _handle(e, r) {
            let t, o;
            try {
                let a = [r.fetch(e)];
                if (this._networkTimeoutSeconds) {
                    let s = d(this._networkTimeoutSeconds * 1000);
                    a.push(s);
                }
                if (o = await Promise.race(a), !o)
                    throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`);
            }
            catch (a) {
                t = a;
            }
            if (!o)
                throw new c("no-response", { url: e.url, error: t });
            return o;
        }
    };
    var $ = class extends l {
        constructor(e) { super(e); this.plugins.some(r => "cacheWillUpdate" in r) || this.plugins.unshift(w); }
        async _handle(e, r) {
            let t = [], o = r.fetchAndCachePut(e).catch(() => { }), a = await r.cacheMatch(e), s;
            if (!a)
                try {
                    a = await o;
                }
                catch (i) {
                    s = i;
                }
            if (!a)
                throw new c("no-response", { url: e.url, error: s });
            return a;
        }
    };
    var { CacheOnly: zr, NetworkFirst: et, NetworkOnly: rt, StaleWhileRevalidate: tt, Strategy: ot, StrategyHandler: st, CacheFirst: nt } = R;
    return { CacheFirst: nt, CacheOnly: zr, NetworkFirst: et, NetworkOnly: rt, StaleWhileRevalidate: tt, Strategy: ot, StrategyHandler: st };
})();
