/* https://cdn.esm.sh/v41/workbox-precaching@6.1.5/deno/workbox-precaching.js */
const mod7 = (async () => {
    var le = Object.defineProperty;
    var ue = (o, e) => {
        for (var r in e)
            le(o, r, { get: e[r], enumerable: !0 });
    };
    var W = {};
    ue(W, { PrecacheController: () => v, PrecacheFallbackPlugin: () => V, PrecacheRoute: () => C, PrecacheStrategy: () => h, addPlugins: () => z, addRoute: () => k, cleanupOutdatedCaches: () => oe, createHandlerBoundToURL: () => se, getCacheKeyForURL: () => ae, matchPrecache: () => ne, precache: () => j, precacheAndRoute: () => ie });
    "use strict";
    try {
        self["workbox:core:6.1.5"] && _();
    }
    catch (o) { }
    var he = (o, ...e) => { let r = o; return e.length > 0 && (r += ` :: ${JSON.stringify(e)}`), r; };
    var S = he;
    var c = class extends Error {
        constructor(e, r) { let t = S(e, r); super(t); this.name = e, this.details = r; }
    };
    var p = { googleAnalytics: "googleAnalytics", precache: "precache-v2", prefix: "workbox", runtime: "runtime", suffix: typeof registration != "undefined" ? registration.scope : "" }, U = o => [p.prefix, o, p.suffix].filter(e => e && e.length > 0).join("-"), pe = o => {
        for (let e of Object.keys(p))
            o(e);
    }, m = { updateDetails: o => { pe(e => { typeof o[e] == "string" && (p[e] = o[e]); }); }, getGoogleAnalyticsName: o => o || U(p.googleAnalytics), getPrecacheName: o => o || U(p.precache), getPrefix: () => p.prefix, getRuntimeName: o => o || U(p.runtime), getSuffix: () => p.suffix };
    function L(o, e) { let r = e(); return o.waitUntil(r), r; }
    "use strict";
    try {
        self["workbox:precaching:6.1.5"] && _();
    }
    catch (o) { }
    var de = "__WB_REVISION__";
    function A(o) {
        if (!o)
            throw new c("add-to-cache-list-unexpected-type", { entry: o });
        if (typeof o == "string") {
            let a = new URL(o, location.href);
            return { cacheKey: a.href, url: a.href };
        }
        let { revision: e, url: r } = o;
        if (!r)
            throw new c("add-to-cache-list-unexpected-type", { entry: o });
        if (!e) {
            let a = new URL(r, location.href);
            return { cacheKey: a.href, url: a.href };
        }
        let t = new URL(r, location.href), s = new URL(r, location.href);
        return t.searchParams.set(de, e), { cacheKey: t.href, url: s.href };
    }
    var P = class {
        constructor() {
            this.updatedURLs = [], this.notUpdatedURLs = [], this.handlerWillStart = async ({ request: e, state: r }) => { r && (r.originalRequest = e); }, this.cachedResponseWillBeUsed = async ({ event: e, state: r, cachedResponse: t }) => {
                if (e.type === "install") {
                    let s = r.originalRequest.url;
                    t ? this.notUpdatedURLs.push(s) : this.updatedURLs.push(s);
                }
                return t;
            };
        }
    };
    var $ = class {
        constructor({ precacheController: e }) { this.cacheKeyWillBeUsed = async ({ request: r, params: t }) => { let s = t && t.cacheKey || this._precacheController.getCacheKeyForURL(r.url); return s ? new Request(s) : r; }, this._precacheController = e; }
    };
    var b;
    function M() {
        if (b === void 0) {
            let o = new Response("");
            if ("body" in o)
                try {
                    new Response(o.body), b = !0;
                }
                catch (e) {
                    b = !1;
                }
            b = !1;
        }
        return b;
    }
    async function I(o, e) {
        let r = null;
        if (o.url && (r = new URL(o.url).origin), r !== self.location.origin)
            throw new c("cross-origin-copy-response", { origin: r });
        let t = o.clone(), s = { headers: new Headers(t.headers), status: t.status, statusText: t.statusText }, a = e ? e(s) : s, n = M() ? t.body : await t.blob();
        return new Response(n, a);
    }
    var H = o => new URL(String(o), location.href).href.replace(new RegExp(`^${location.origin}`), "");
    function B(o, e) {
        let r = new URL(o);
        for (let t of e)
            r.searchParams.delete(t);
        return r.href;
    }
    async function G(o, e, r, t) {
        let s = B(e.url, r);
        if (e.url === s)
            return o.match(e, t);
        let a = { ...t, ignoreSearch: !0 }, n = await o.keys(e, a);
        for (let i of n) {
            let l = B(i.url, r);
            if (s === l)
                return o.match(i, t);
        }
    }
    var T = class {
        constructor() { this.promise = new Promise((e, r) => { this.resolve = e, this.reject = r; }); }
    };
    var J = new Set;
    async function Q() {
        for (let o of J)
            await o();
    }
    function Y(o) { return new Promise(e => setTimeout(e, o)); }
    "use strict";
    try {
        self["workbox:strategies:6.1.5"] && _();
    }
    catch (o) { }
    function E(o) { return typeof o == "string" ? new Request(o) : o; }
    var O = class {
        constructor(e, r) {
            this._cacheKeys = {}, Object.assign(this, r), this.event = r.event, this._strategy = e, this._handlerDeferred = new T, this._extendLifetimePromises = [], this._plugins = [...e.plugins], this._pluginStateMap = new Map;
            for (let t of this._plugins)
                this._pluginStateMap.set(t, {});
            this.event.waitUntil(this._handlerDeferred.promise);
        }
        async fetch(e) {
            let { event: r } = this, t = E(e);
            if (t.mode === "navigate" && r instanceof FetchEvent && r.preloadResponse) {
                let n = await r.preloadResponse;
                if (n)
                    return n;
            }
            let s = this.hasCallback("fetchDidFail") ? t.clone() : null;
            try {
                for (let n of this.iterateCallbacks("requestWillFetch"))
                    t = await n({ request: t.clone(), event: r });
            }
            catch (n) {
                throw new c("plugin-error-request-will-fetch", { thrownError: n });
            }
            let a = t.clone();
            try {
                let n;
                n = await fetch(t, t.mode === "navigate" ? void 0 : this._strategy.fetchOptions);
                for (let i of this.iterateCallbacks("fetchDidSucceed"))
                    n = await i({ event: r, request: a, response: n });
                return n;
            }
            catch (n) {
                throw s && await this.runCallbacks("fetchDidFail", { error: n, event: r, originalRequest: s.clone(), request: a.clone() }), n;
            }
        }
        async fetchAndCachePut(e) { let r = await this.fetch(e), t = r.clone(); return this.waitUntil(this.cachePut(e, t)), r; }
        async cacheMatch(e) {
            let r = E(e), t, { cacheName: s, matchOptions: a } = this._strategy, n = await this.getCacheKey(r, "read"), i = { ...a, cacheName: s };
            t = await caches.match(n, i);
            for (let l of this.iterateCallbacks("cachedResponseWillBeUsed"))
                t = await l({ cacheName: s, matchOptions: a, cachedResponse: t, request: n, event: this.event }) || void 0;
            return t;
        }
        async cachePut(e, r) {
            let t = E(e);
            await Y(0);
            let s = await this.getCacheKey(t, "write");
            if (!r)
                throw new c("cache-put-with-no-response", { url: H(s.url) });
            let a = await this._ensureResponseSafeToCache(r);
            if (!a)
                return !1;
            let { cacheName: n, matchOptions: i } = this._strategy, l = await self.caches.open(n), w = this.hasCallback("cacheDidUpdate"), f = w ? await G(l, s.clone(), ["__WB_REVISION__"], i) : null;
            try {
                await l.put(s, w ? a.clone() : a);
            }
            catch (g) {
                throw g.name === "QuotaExceededError" && await Q(), g;
            }
            for (let g of this.iterateCallbacks("cacheDidUpdate"))
                await g({ cacheName: n, oldResponse: f, newResponse: a.clone(), request: s, event: this.event });
            return !0;
        }
        async getCacheKey(e, r) {
            if (!this._cacheKeys[r]) {
                let t = e;
                for (let s of this.iterateCallbacks("cacheKeyWillBeUsed"))
                    t = E(await s({ mode: r, request: t, event: this.event, params: this.params }));
                this._cacheKeys[r] = t;
            }
            return this._cacheKeys[r];
        }
        hasCallback(e) {
            for (let r of this._strategy.plugins)
                if (e in r)
                    return !0;
            return !1;
        }
        async runCallbacks(e, r) {
            for (let t of this.iterateCallbacks(e))
                await t(r);
        }
        *iterateCallbacks(e) {
            for (let r of this._strategy.plugins)
                if (typeof r[e] == "function") {
                    let t = this._pluginStateMap.get(r);
                    yield a => { let n = { ...a, state: t }; return r[e](n); };
                }
        }
        waitUntil(e) { return this._extendLifetimePromises.push(e), e; }
        async doneWaiting() {
            let e;
            for (; e = this._extendLifetimePromises.shift();)
                await e;
        }
        destroy() { this._handlerDeferred.resolve(); }
        async _ensureResponseSafeToCache(e) {
            let r = e, t = !1;
            for (let s of this.iterateCallbacks("cacheWillUpdate"))
                if (r = await s({ request: this.request, response: r, event: this.event }) || void 0, t = !0, !r)
                    break;
            return t || r && r.status !== 200 && (r = void 0), r;
        }
    };
    var D = class {
        constructor(e = {}) { this.cacheName = m.getRuntimeName(e.cacheName), this.plugins = e.plugins || [], this.fetchOptions = e.fetchOptions, this.matchOptions = e.matchOptions; }
        handle(e) { let [r] = this.handleAll(e); return r; }
        handleAll(e) { e instanceof FetchEvent && (e = { event: e, request: e.request }); let r = e.event, t = typeof e.request == "string" ? new Request(e.request) : e.request, s = "params" in e ? e.params : void 0, a = new O(this, { event: r, request: t, params: s }), n = this._getResponse(a, t, r), i = this._awaitComplete(n, a, t, r); return [n, i]; }
        async _getResponse(e, r, t) {
            await e.runCallbacks("handlerWillStart", { event: t, request: r });
            let s;
            try {
                if (s = await this._handle(r, e), !s || s.type === "error")
                    throw new c("no-response", { url: r.url });
            }
            catch (a) {
                for (let n of e.iterateCallbacks("handlerDidError"))
                    if (s = await n({ error: a, event: t, request: r }), s)
                        break;
                if (!s)
                    throw a;
            }
            for (let a of e.iterateCallbacks("handlerWillRespond"))
                s = await a({ event: t, request: r, response: s });
            return s;
        }
        async _awaitComplete(e, r, t, s) {
            let a, n;
            try {
                a = await e;
            }
            catch (i) { }
            try {
                await r.runCallbacks("handlerDidRespond", { event: s, request: t, response: a }), await r.doneWaiting();
            }
            catch (i) {
                n = i;
            }
            if (await r.runCallbacks("handlerDidComplete", { event: s, request: t, response: a, error: n }), r.destroy(), n)
                throw n;
        }
    };
    var h = class extends D {
        constructor(e = {}) { e.cacheName = m.getPrecacheName(e.cacheName), super(e), this._fallbackToNetwork = e.fallbackToNetwork !== !1, this.plugins.push(h.copyRedirectedCacheableResponsesPlugin); }
        async _handle(e, r) { let t = await r.cacheMatch(e); return t || (r.event && r.event.type === "install" ? await this._handleInstall(e, r) : await this._handleFetch(e, r)); }
        async _handleFetch(e, r) {
            let t;
            if (this._fallbackToNetwork)
                t = await r.fetch(e);
            else
                throw new c("missing-precache-entry", { cacheName: this.cacheName, url: e.url });
            return t;
        }
        async _handleInstall(e, r) {
            this._useDefaultCacheabilityPluginIfNeeded();
            let t = await r.fetch(e);
            if (!await r.cachePut(e, t.clone()))
                throw new c("bad-precaching-response", { url: e.url, status: t.status });
            return t;
        }
        _useDefaultCacheabilityPluginIfNeeded() {
            let e = null, r = 0;
            for (let [t, s] of this.plugins.entries())
                s !== h.copyRedirectedCacheableResponsesPlugin && (s === h.defaultPrecacheCacheabilityPlugin && (e = t), s.cacheWillUpdate && r++);
            r === 0 ? this.plugins.push(h.defaultPrecacheCacheabilityPlugin) : r > 1 && e !== null && this.plugins.splice(e, 1);
        }
    };
    h.defaultPrecacheCacheabilityPlugin = { async cacheWillUpdate({ response: o }) { return !o || o.status >= 400 ? null : o; } };
    h.copyRedirectedCacheableResponsesPlugin = { async cacheWillUpdate({ response: o }) { return o.redirected ? await I(o) : o; } };
    var v = class {
        constructor({ cacheName: e, plugins: r = [], fallbackToNetwork: t = !0 } = {}) { this._urlsToCacheKeys = new Map, this._urlsToCacheModes = new Map, this._cacheKeysToIntegrities = new Map, this._strategy = new h({ cacheName: m.getPrecacheName(e), plugins: [...r, new $({ precacheController: this })], fallbackToNetwork: t }), this.install = this.install.bind(this), this.activate = this.activate.bind(this); }
        get strategy() { return this._strategy; }
        precache(e) { this.addToCacheList(e), this._installAndActiveListenersAdded || (self.addEventListener("install", this.install), self.addEventListener("activate", this.activate), this._installAndActiveListenersAdded = !0); }
        addToCacheList(e) {
            let r = [];
            for (let t of e) {
                typeof t == "string" ? r.push(t) : t && t.revision === void 0 && r.push(t.url);
                let { cacheKey: s, url: a } = A(t), n = typeof t != "string" && t.revision ? "reload" : "default";
                if (this._urlsToCacheKeys.has(a) && this._urlsToCacheKeys.get(a) !== s)
                    throw new c("add-to-cache-list-conflicting-entries", { firstEntry: this._urlsToCacheKeys.get(a), secondEntry: s });
                if (typeof t != "string" && t.integrity) {
                    if (this._cacheKeysToIntegrities.has(s) && this._cacheKeysToIntegrities.get(s) !== t.integrity)
                        throw new c("add-to-cache-list-conflicting-integrities", { url: a });
                    this._cacheKeysToIntegrities.set(s, t.integrity);
                }
                if (this._urlsToCacheKeys.set(a, s), this._urlsToCacheModes.set(a, n), r.length > 0) {
                    let i = `Workbox is precaching URLs without revision info: ${r.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;
                    console.warn(i);
                }
            }
        }
        install(e) {
            return L(e, async () => {
                let r = new P;
                this.strategy.plugins.push(r);
                for (let [a, n] of this._urlsToCacheKeys) {
                    let i = this._cacheKeysToIntegrities.get(n), l = this._urlsToCacheModes.get(a), w = new Request(a, { integrity: i, cache: l, credentials: "same-origin" });
                    await Promise.all(this.strategy.handleAll({ params: { cacheKey: n }, request: w, event: e }));
                }
                let { updatedURLs: t, notUpdatedURLs: s } = r;
                return { updatedURLs: t, notUpdatedURLs: s };
            });
        }
        activate(e) {
            return L(e, async () => {
                let r = await self.caches.open(this.strategy.cacheName), t = await r.keys(), s = new Set(this._urlsToCacheKeys.values()), a = [];
                for (let n of t)
                    s.has(n.url) || (await r.delete(n), a.push(n.url));
                return { deletedURLs: a };
            });
        }
        getURLsToCacheKeys() { return this._urlsToCacheKeys; }
        getCachedURLs() { return [...this._urlsToCacheKeys.keys()]; }
        getCacheKeyForURL(e) { let r = new URL(e, location.href); return this._urlsToCacheKeys.get(r.href); }
        async matchPrecache(e) {
            let r = e instanceof Request ? e.url : e, t = this.getCacheKeyForURL(r);
            if (t)
                return (await self.caches.open(this.strategy.cacheName)).match(t);
        }
        createHandlerBoundToURL(e) {
            let r = this.getCacheKeyForURL(e);
            if (!r)
                throw new c("non-precached-url", { url: e });
            return t => (t.request = new Request(e), t.params = { cacheKey: r, ...t.params }, this.strategy.handle(t));
        }
    };
    var q, u = () => (q || (q = new v), q);
    function z(o) { u().strategy.plugins.push(...o); }
    "use strict";
    try {
        self["workbox:routing:6.1.5"] && _();
    }
    catch (o) { }
    var N = "GET";
    var y = o => o && typeof o == "object" ? o : { handle: o };
    var d = class {
        constructor(e, r, t = N) { this.handler = y(r), this.match = e, this.method = t; }
        setCatchHandler(e) { this.catchHandler = y(e); }
    };
    var F = class extends d {
        constructor(e, r, t) {
            let s = ({ url: a }) => {
                let n = e.exec(a.href);
                if (!!n && !(a.origin !== location.origin && n.index !== 0))
                    return n.slice(1);
            };
            super(s, r, t);
        }
    };
    var K = class {
        constructor() { this._routes = new Map, this._defaultHandlerMap = new Map; }
        get routes() { return this._routes; }
        addFetchListener() { self.addEventListener("fetch", e => { let { request: r } = e, t = this.handleRequest({ request: r, event: e }); t && e.respondWith(t); }); }
        addCacheListener() {
            self.addEventListener("message", e => {
                if (e.data && e.data.type === "CACHE_URLS") {
                    let { payload: r } = e.data, t = Promise.all(r.urlsToCache.map(s => { typeof s == "string" && (s = [s]); let a = new Request(...s); return this.handleRequest({ request: a, event: e }); }));
                    e.waitUntil(t), e.ports && e.ports[0] && t.then(() => e.ports[0].postMessage(!0));
                }
            });
        }
        handleRequest({ request: e, event: r }) {
            let t = new URL(e.url, location.href);
            if (!t.protocol.startsWith("http"))
                return;
            let s = t.origin === location.origin, { params: a, route: n } = this.findMatchingRoute({ event: r, request: e, sameOrigin: s, url: t }), i = n && n.handler, l = [], w = e.method;
            if (!i && this._defaultHandlerMap.has(w) && (i = this._defaultHandlerMap.get(w)), !i)
                return;
            let f;
            try {
                f = i.handle({ url: t, request: e, event: r, params: a });
            }
            catch (R) {
                f = Promise.reject(R);
            }
            let g = n && n.catchHandler;
            return f instanceof Promise && (this._catchHandler || g) && (f = f.catch(async (R) => {
                if (g)
                    try {
                        return await g.handle({ url: t, request: e, event: r, params: a });
                    }
                    catch (ce) {
                        R = ce;
                    }
                if (this._catchHandler)
                    return this._catchHandler.handle({ url: t, request: e, event: r });
                throw R;
            })), f;
        }
        findMatchingRoute({ url: e, sameOrigin: r, request: t, event: s }) {
            let a = this._routes.get(t.method) || [];
            for (let n of a) {
                let i, l = n.match({ url: e, sameOrigin: r, request: t, event: s });
                if (l)
                    return i = l, (Array.isArray(l) && l.length === 0 || l.constructor === Object && Object.keys(l).length === 0 || typeof l == "boolean") && (i = void 0), { route: n, params: i };
            }
            return {};
        }
        setDefaultHandler(e, r = N) { this._defaultHandlerMap.set(r, y(e)); }
        setCatchHandler(e) { this._catchHandler = y(e); }
        registerRoute(e) { this._routes.has(e.method) || this._routes.set(e.method, []), this._routes.get(e.method).push(e); }
        unregisterRoute(e) {
            if (!this._routes.has(e.method))
                throw new c("unregister-route-but-not-found-with-method", { method: e.method });
            let r = this._routes.get(e.method).indexOf(e);
            if (r > -1)
                this._routes.get(e.method).splice(r, 1);
            else
                throw new c("unregister-route-route-not-registered");
        }
    };
    var x, X = () => (x || (x = new K, x.addFetchListener(), x.addCacheListener()), x);
    function Z(o, e, r) {
        let t;
        if (typeof o == "string") {
            let a = new URL(o, location.href), n = ({ url: i }) => i.href === a.href;
            t = new d(n, e, r);
        }
        else if (o instanceof RegExp)
            t = new F(o, e, r);
        else if (typeof o == "function")
            t = new d(o, e, r);
        else if (o instanceof d)
            t = o;
        else
            throw new c("unsupported-route-type", { moduleName: "workbox-routing", funcName: "registerRoute", paramName: "capture" });
        return X().registerRoute(t), t;
    }
    function ee(o, e = []) {
        for (let r of [...o.searchParams.keys()])
            e.some(t => t.test(r)) && o.searchParams.delete(r);
        return o;
    }
    function* re(o, { ignoreURLParametersMatching: e = [/^utm_/, /^fbclid$/], directoryIndex: r = "index.html", cleanURLs: t = !0, urlManipulation: s } = {}) {
        let a = new URL(o, location.href);
        a.hash = "", yield a.href;
        let n = ee(a, e);
        if (yield n.href, r && n.pathname.endsWith("/")) {
            let i = new URL(n.href);
            i.pathname += r, yield i.href;
        }
        if (t) {
            let i = new URL(n.href);
            i.pathname += ".html", yield i.href;
        }
        if (s) {
            let i = s({ url: a });
            for (let l of i)
                yield l.href;
        }
    }
    var C = class extends d {
        constructor(e, r) {
            let t = ({ request: s }) => {
                let a = e.getURLsToCacheKeys();
                for (let n of re(s.url, r)) {
                    let i = a.get(n);
                    if (i)
                        return { cacheKey: i };
                }
            };
            super(t, e.strategy);
        }
    };
    function k(o) { let e = u(), r = new C(e, o); Z(r); }
    var ge = "-precache-", te = async (o, e = ge) => { let t = (await self.caches.keys()).filter(s => s.includes(e) && s.includes(self.registration.scope) && s !== o); return await Promise.all(t.map(s => self.caches.delete(s))), t; };
    function oe() { self.addEventListener("activate", o => { let e = m.getPrecacheName(); o.waitUntil(te(e).then(r => { })); }); }
    function se(o) { return u().createHandlerBoundToURL(o); }
    function ae(o) { return u().getCacheKeyForURL(o); }
    function ne(o) { return u().matchPrecache(o); }
    function j(o) { u().precache(o); }
    function ie(o, e) { j(o), k(e); }
    var V = class {
        constructor({ fallbackURL: e, precacheController: r }) { this.handlerDidError = () => this._precacheController.matchPrecache(this._fallbackURL), this._fallbackURL = e, this._precacheController = r || u(); }
    };
    var { cleanupOutdatedCaches: ls, matchPrecache: us, PrecacheRoute: hs, addRoute: ps, createHandlerBoundToURL: ds, precache: fs, precacheAndRoute: gs, PrecacheController: ms, addPlugins: ws, getCacheKeyForURL: ys, PrecacheStrategy: Rs, PrecacheFallbackPlugin: bs } = W;
    return { PrecacheController: ms, PrecacheFallbackPlugin: bs, PrecacheRoute: hs, PrecacheStrategy: Rs, addPlugins: ws, addRoute: ps, cleanupOutdatedCaches: ls, createHandlerBoundToURL: ds, getCacheKeyForURL: ys, matchPrecache: us, precache: fs, precacheAndRoute: gs };
})();
